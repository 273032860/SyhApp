{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/boxBlur.js", "../../three/examples/jsm/tsl/display/SSRNode.js"],
  "sourcesContent": ["import { Fn, vec2, uv, Loop, vec4, premultiplyAlpha, unpremultiplyAlpha, max, int, textureSize, nodeObject, convertToTexture } from 'three/tsl';\n\n/**\n * Applies a box blur effect to the given texture node.\n *\n * Compared to Gaussian blur, box blur produces a more blocky result but with better performance when correctly\n * configured. It is intended for mobile devices or performance restricted use cases where Gaussian is too heavy.\n *\n * The (kernel) `size` parameter should be small (1, 2 or 3) since it determines the number of samples based on (size * 2 + 1)^2.\n * This implementation uses a single pass approach so the kernel is not applied as a separable filter. That means larger\n * kernels won't perform well. Use Gaussian instead if you need a more high-quality blur.\n *\n * To produce wider blurs, increase the `separation` parameter instead which has no influence on the performance.\n *\n * Reference: {@link https://github.com/lettier/3d-game-shaders-for-beginners/blob/master/demonstration/shaders/fragment/box-blur.frag}.\n *\n * @function\n * @param {Node<vec4>} textureNode - The texture node that should be blurred.\n * @param {Object} [options={}] - Additional options for the hash blur effect.\n * @param {Node<int>} [options.size=int(1)] - Controls the blur's kernel. For performant results, the range should within [1, 3].\n * @param {Node<int>} [options.separation=int(1)] - Spreads out the blur without having to sample additional fragments. Ranges from [1, Infinity].\n * @param {boolean} [options.premultipliedAlpha=false] - Whether to use premultiplied alpha for the blur effect.\n * @return {Node<vec4>} The blurred texture node.\n */\nexport const boxBlur = /*#__PURE__*/ Fn( ( [ textureNode, options = {} ] ) => {\n\n\ttextureNode = convertToTexture( textureNode );\n\n\tconst size = nodeObject( options.size ) || int( 1 );\n\tconst separation = nodeObject( options.separation ) || int( 1 );\n\tconst premultipliedAlpha = options.premultipliedAlpha || false;\n\n\tconst tap = ( uv ) => {\n\n\t\tconst sample = textureNode.sample( uv );\n\n\t\treturn premultipliedAlpha ? premultiplyAlpha( sample ) : sample;\n\n\t};\n\n\tconst targetUV = textureNode.uvNode || uv();\n\n\tconst result = vec4( 0 );\n\tconst sep = max( separation, 1 );\n\tconst count = int( 0 );\n\tconst pixelStep = vec2( 1 ).div( textureSize( textureNode ) );\n\n\tLoop( { start: size.negate(), end: size, name: 'i', condition: '<=' }, ( { i } ) => {\n\n\t\tLoop( { start: size.negate(), end: size, name: 'j', condition: '<=' }, ( { j } ) => {\n\n\t\t\tconst uvs = targetUV.add( vec2( i, j ).mul( pixelStep ).mul( sep ) );\n\t\t\tresult.addAssign( tap( uvs ) );\n\t\t\tcount.addAssign( 1 );\n\n\t\t} );\n\n\t} );\n\n\tresult.divAssign( count );\n\n\treturn premultipliedAlpha ? unpremultiplyAlpha( result ) : result;\n\n} );\n", "import { HalfFloatType, RenderTarget, Vector2, RendererUtils, QuadMesh, TempNode, NodeMaterial, NodeUpdateType, LinearFilter, LinearMipmapLinearFilter } from 'three/webgpu';\nimport { texture, reference, viewZToPerspectiveDepth, logarithmicDepthToViewZ, getScreenPosition, getViewPosition, sqrt, mul, div, cross, float, Continue, Break, Loop, int, max, abs, sub, If, dot, reflect, normalize, screenCoordinate, nodeObject, Fn, passTexture, uv, uniform, perspectiveDepthToViewZ, orthographicDepthToViewZ, vec2, vec3, vec4 } from 'three/tsl';\nimport { boxBlur } from './boxBlur.js';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\nlet _rendererState;\n\n/**\n * Post processing node for computing screen space reflections (SSR).\n *\n * Reference: {@link https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html}\n *\n * @augments TempNode\n * @three_import import { ssr } from 'three/addons/tsl/display/SSRNode.js';\n */\nclass SSRNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SSRNode';\n\n\t}\n\n\t/**\n\t * Constructs a new SSR node.\n\t *\n\t * @param {Node<vec4>} colorNode - The node that represents the beauty pass.\n\t * @param {Node<float>} depthNode - A node that represents the beauty pass's depth.\n\t * @param {Node<vec3>} normalNode - A node that represents the beauty pass's normals.\n\t * @param {Node<float>} metalnessNode - A node that represents the beauty pass's metalness.\n\t * @param {?Node<float>} [roughnessNode=null] - A node that represents the beauty pass's roughness.\n\t * @param {?Camera} [camera=null] - The camera the scene is rendered with.\n\t */\n\tconstructor( colorNode, depthNode, normalNode, metalnessNode, roughnessNode = null, camera = null ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The node that represents the beauty pass.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * A node that represents the beauty pass's depth.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.depthNode = depthNode;\n\n\t\t/**\n\t\t * A node that represents the beauty pass's normals.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.normalNode = normalNode;\n\n\t\t/**\n\t\t * A node that represents the beauty pass's metalness.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.metalnessNode = metalnessNode;\n\n\t\t/**\n\t\t * Whether the SSR reflections should be blurred or not. Blurring is a costly\n\t\t * operation so turn it off if you encounter performance issues on certain\n\t\t * devices.\n\t\t *\n\t\t * @private\n\t\t * @type {Node<float>}\n\t\t * @default false\n\t\t */\n\t\tthis.roughnessNode = roughnessNode;\n\n\t\t/**\n\t\t * The resolution scale. Valid values are in the range\n\t\t * `[0,1]`. `1` means best quality but also results in\n\t\t * more computational overhead. Setting to `0.5` means\n\t\t * the effect is computed in half-resolution.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.resolutionScale = 1;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * Controls how far a fragment can reflect. Increasing this value result in more\n\t\t * computational overhead but also increases the reflection distance.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.maxDistance = uniform( 1 );\n\n\t\t/**\n\t\t * Controls the cutoff between what counts as a possible reflection hit and what does not.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.thickness = uniform( 0.1 );\n\n\t\t/**\n\t\t * Controls how the SSR reflections are blended with the beauty pass.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.opacity = uniform( 1 );\n\n\t\t/**\n\t\t * This parameter controls how detailed the raymarching process works.\n\t\t * The value ranges is `[0,1]` where `1` means best quality (the maximum number\n\t\t * of raymarching iterations/samples) and `0` means no samples at all.\n\t\t *\n\t\t * A quality of `0.5` is usually sufficient for most use cases. Try to keep\n\t\t * this parameter as low as possible. Larger values result in noticeable more\n\t\t * overhead.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.quality = uniform( 0.5 );\n\n\t\t/**\n\t\t * The quality of the blur. Must be an integer in the range `[1,3]`.\n\t\t *\n\t\t * @type {UniformNode<int>}\n\t\t */\n\t\tthis.blurQuality = uniform( 2 );\n\n\t\t//\n\n\t\tif ( camera === null ) {\n\n\t\t\tif ( this.colorNode.passNode && this.colorNode.passNode.isPassNode === true ) {\n\n\t\t\t\tcamera = this.colorNode.passNode.camera;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.TSL: No camera found. ssr() requires a camera.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The spread of the blur. Automatically set when generating mips.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<int>}\n\t\t */\n\t\tthis._blurSpread = uniform( 1 );\n\n\t\t/**\n\t\t * Represents the projection matrix of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrix = uniform( camera.projectionMatrix );\n\n\t\t/**\n\t\t * Represents the inverse projection matrix of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrixInverse = uniform( camera.projectionMatrixInverse );\n\n\t\t/**\n\t\t * Represents the near value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraNear = reference( 'near', 'float', camera );\n\n\t\t/**\n\t\t * Represents the far value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraFar = reference( 'far', 'float', camera );\n\n\t\t/**\n\t\t * Whether the scene's camera is perspective or orthographic.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<bool>}\n\t\t */\n\t\tthis._isPerspectiveCamera = uniform( camera.isPerspectiveCamera );\n\n\t\t/**\n\t\t * The resolution of the pass.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._resolution = uniform( new Vector2() );\n\n\t\t/**\n\t\t * The render target the SSR is rendered into.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._ssrRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._ssrRenderTarget.texture.name = 'SSRNode.SSR';\n\n\t\t/**\n\t\t * The render target for the blurred SSR reflections.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._blurRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType, minFilter: LinearMipmapLinearFilter, magFilter: LinearFilter } );\n\t\tthis._blurRenderTarget.texture.name = 'SSRNode.Blur';\n\t\tthis._blurRenderTarget.texture.mipmaps.push( {}, {}, {}, {}, {} );\n\n\t\t/**\n\t\t * The material that is used to render the effect.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._ssrMaterial = new NodeMaterial();\n\t\tthis._ssrMaterial.name = 'SSRNode.SSR';\n\n\t\t/**\n\t\t * The blur material.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._blurMaterial = new NodeMaterial();\n\t\tthis._blurMaterial.name = 'SSRNode.Blur';\n\n\t\t/**\n\t\t * The copy material.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._copyMaterial = new NodeMaterial();\n\t\tthis._copyMaterial.name = 'SSRNode.Copy';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._ssrRenderTarget.texture );\n\n\t\tlet blurredTextureNode = null;\n\n\t\tif ( this.roughnessNode !== null ) {\n\n\t\t\tconst mips = this._blurRenderTarget.texture.mipmaps.length - 1;\n\t\t\tconst lod = float( this.roughnessNode ).mul( mips ).clamp( 0, mips );\n\n\t\t\tblurredTextureNode = passTexture( this, this._blurRenderTarget.texture ).level( lod );\n\n\t\t}\n\n\t\t/**\n\t\t * Holds the blurred SSR reflections.\n\t\t *\n\t\t * @private\n\t\t * @type {?PassTextureNode}\n\t\t */\n\t\tthis._blurredTextureNode = blurredTextureNode;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this.roughnessNode !== null ? this._blurredTextureNode : this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\twidth = Math.round( this.resolutionScale * width );\n\t\theight = Math.round( this.resolutionScale * height );\n\n\t\tthis._resolution.value.set( width, height );\n\t\tthis._ssrRenderTarget.setSize( width, height );\n\t\tthis._blurRenderTarget.setSize( width, height );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\tconst ssrRenderTarget = this._ssrRenderTarget;\n\t\tconst blurRenderTarget = this._blurRenderTarget;\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\n\t\t_quadMesh.material = this._ssrMaterial;\n\n\t\tthis.setSize( size.width, size.height );\n\n\t\t// clear\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\t// ssr\n\n\t\trenderer.setRenderTarget( ssrRenderTarget );\n\t\t_quadMesh.render( renderer );\n\n\t\t// blur (optional)\n\n\t\tif ( this.roughnessNode !== null ) {\n\n\t\t\t// blur mips but leave the base mip unblurred\n\n\t\t\tfor ( let i = 0; i < blurRenderTarget.texture.mipmaps.length; i ++ ) {\n\n\t\t\t\t_quadMesh.material = ( i === 0 ) ? this._copyMaterial : this._blurMaterial;\n\n\t\t\t\tthis._blurSpread.value = i;\n\t\t\t\trenderer.setRenderTarget( blurRenderTarget, 0, i );\n\t\t\t\t_quadMesh.render( renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst uvNode = uv();\n\n\t\tconst pointToLineDistance = Fn( ( [ point, linePointA, linePointB ] )=> {\n\n\t\t\t// https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\n\t\t\treturn cross( point.sub( linePointA ), point.sub( linePointB ) ).length().div( linePointB.sub( linePointA ).length() );\n\n\t\t} );\n\n\t\tconst pointPlaneDistance = Fn( ( [ point, planePoint, planeNormal ] )=> {\n\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t// http://paulbourke.net/geometry/pointlineplane/\n\n\t\t\tconst d = mul( planeNormal.x, planePoint.x ).add( mul( planeNormal.y, planePoint.y ) ).add( mul( planeNormal.z, planePoint.z ) ).negate().toVar();\n\n\t\t\tconst denominator = sqrt( mul( planeNormal.x, planeNormal.x, ).add( mul( planeNormal.y, planeNormal.y ) ).add( mul( planeNormal.z, planeNormal.z ) ) ).toVar();\n\t\t\tconst distance = div( mul( planeNormal.x, point.x ).add( mul( planeNormal.y, point.y ) ).add( mul( planeNormal.z, point.z ) ).add( d ), denominator );\n\t\t\treturn distance;\n\n\t\t} );\n\n\t\tconst getViewZ = Fn( ( [ depth ] ) => {\n\n\t\t\tlet viewZNode;\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tviewZNode = perspectiveDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tviewZNode = orthographicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t}\n\n\t\t\treturn viewZNode;\n\n\t\t} );\n\n\t\tconst sampleDepth = ( uv ) => {\n\n\t\t\tconst depth = this.depthNode.sample( uv ).r;\n\n\t\t\tif ( builder.renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tconst viewZ = logarithmicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t\treturn viewZToPerspectiveDepth( viewZ, this._cameraNear, this._cameraFar );\n\n\t\t\t}\n\n\t\t\treturn depth;\n\n\t\t};\n\n\t\tconst ssr = Fn( () => {\n\n\t\t\tconst metalness = float( this.metalnessNode );\n\n\t\t\t// fragments with no metalness do not reflect their environment\n\t\t\tmetalness.equal( 0.0 ).discard();\n\n\t\t\t// compute some standard FX entities\n\t\t\tconst depth = sampleDepth( uvNode ).toVar();\n\t\t\tconst viewPosition = getViewPosition( uvNode, depth, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\tconst viewNormal = this.normalNode.rgb.normalize().toVar();\n\n\t\t\t// compute the direction from the position in view space to the camera\n\t\t\tconst viewIncidentDir = ( ( this.camera.isPerspectiveCamera ) ? normalize( viewPosition ) : vec3( 0, 0, - 1 ) ).toVar();\n\n\t\t\t// compute the direction in which the light is reflected on the surface\n\t\t\tconst viewReflectDir = reflect( viewIncidentDir, viewNormal ).toVar();\n\n\t\t\t// adapt maximum distance to the local geometry (see https://www.mathsisfun.com/algebra/vectors-dot-product.html)\n\t\t\tconst maxReflectRayLen = this.maxDistance.div( dot( viewIncidentDir.negate(), viewNormal ) ).toVar();\n\n\t\t\t// compute the maximum point of the reflection ray in view space\n\t\t\tconst d1viewPosition = viewPosition.add( viewReflectDir.mul( maxReflectRayLen ) ).toVar();\n\n\t\t\t// check if d1viewPosition lies behind the camera near plane\n\t\t\tIf( this._isPerspectiveCamera.and( d1viewPosition.z.greaterThan( this._cameraNear.negate() ) ), () => {\n\n\t\t\t\t// if so, ensure d1viewPosition is clamped on the near plane.\n\t\t\t\t// this prevents artifacts during the ray marching process\n\t\t\t\tconst t = sub( this._cameraNear.negate(), viewPosition.z ).div( viewReflectDir.z );\n\t\t\t\td1viewPosition.assign( viewPosition.add( viewReflectDir.mul( t ) ) );\n\n\t\t\t} );\n\n\t\t\t// d0 and d1 are the start and maximum points of the reflection ray in screen space\n\t\t\tconst d0 = screenCoordinate.xy.toVar();\n\t\t\tconst d1 = getScreenPosition( d1viewPosition, this._cameraProjectionMatrix ).mul( this._resolution ).toVar();\n\n\t\t\t// below variables are used to control the raymarching process\n\n\t\t\t// total length of the ray\n\t\t\tconst totalLen = d1.sub( d0 ).length().toVar();\n\n\t\t\t// offset in x and y direction\n\t\t\tconst xLen = d1.x.sub( d0.x ).toVar();\n\t\t\tconst yLen = d1.y.sub( d0.y ).toVar();\n\n\t\t\t// determine the larger delta\n\t\t\t// The larger difference will help to determine how much to travel in the X and Y direction each iteration and\n\t\t\t// how many iterations are needed to travel the entire ray\n\t\t\tconst totalStep = int( max( abs( xLen ), abs( yLen ) ).mul( this.quality.clamp() ) ).toConst();\n\n\t\t\t// step sizes in the x and y directions\n\t\t\tconst xSpan = xLen.div( totalStep ).toVar();\n\t\t\tconst ySpan = yLen.div( totalStep ).toVar();\n\n\t\t\tconst output = vec4( 0 ).toVar();\n\n\t\t\t// the actual ray marching loop\n\t\t\t// starting from d0, the code gradually travels along the ray and looks for an intersection with the geometry.\n\t\t\t// it does not exceed d1 (the maximum ray extend)\n\t\t\tLoop( totalStep, ( { i } ) => {\n\n\t\t\t\t// advance on the ray by computing a new position in screen coordinates\n\t\t\t\tconst xy = vec2( d0.x.add( xSpan.mul( float( i ) ) ), d0.y.add( ySpan.mul( float( i ) ) ) ).toVar();\n\n\t\t\t\t// stop processing if the new position lies outside of the screen\n\t\t\t\tIf( xy.x.lessThan( 0 ).or( xy.x.greaterThan( this._resolution.x ) ).or( xy.y.lessThan( 0 ) ).or( xy.y.greaterThan( this._resolution.y ) ), () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\t// compute new uv, depth and viewZ for the next fragment\n\t\t\t\tconst uvNode = xy.div( this._resolution );\n\t\t\t\tconst d = sampleDepth( uvNode ).toVar();\n\t\t\t\tconst vZ = getViewZ( d ).toVar();\n\n\t\t\t\tconst viewReflectRayZ = float( 0 ).toVar();\n\n\t\t\t\t// normalized distance between the current position xy and the starting point d0\n\t\t\t\tconst s = xy.sub( d0 ).length().div( totalLen );\n\n\t\t\t\t// depending on the camera type, we now compute the z-coordinate of the reflected ray at the current step in view space\n\t\t\t\tIf( this._isPerspectiveCamera, () => {\n\n\t\t\t\t\tconst recipVPZ = float( 1 ).div( viewPosition.z ).toVar();\n\t\t\t\t\tviewReflectRayZ.assign( float( 1 ).div( recipVPZ.add( s.mul( float( 1 ).div( d1viewPosition.z ).sub( recipVPZ ) ) ) ) );\n\n\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\tviewReflectRayZ.assign( viewPosition.z.add( s.mul( d1viewPosition.z.sub( viewPosition.z ) ) ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// if viewReflectRayZ is less or equal than the real z-coordinate at this place, it potentially intersects the geometry\n\t\t\t\tIf( viewReflectRayZ.lessThanEqual( vZ ), () => {\n\n\t\t\t\t\t// compute the distance of the new location to the ray in view space\n\t\t\t\t\t// to clarify vP is the fragment's view position which is not an exact point on the ray\n\t\t\t\t\tconst vP = getViewPosition( uvNode, d, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\t\t\tconst away = pointToLineDistance( vP, viewPosition, d1viewPosition ).toVar();\n\n\t\t\t\t\t// compute the minimum thickness between the current fragment and its neighbor in the x-direction.\n\t\t\t\t\tconst xyNeighbor = vec2( xy.x.add( 1 ), xy.y ).toVar(); // move one pixel\n\t\t\t\t\tconst uvNeighbor = xyNeighbor.div( this._resolution );\n\t\t\t\t\tconst vPNeighbor = getViewPosition( uvNeighbor, d, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\t\t\tconst minThickness = vPNeighbor.x.sub( vP.x ).toVar();\n\t\t\t\t\tminThickness.mulAssign( 3 ); // expand a bit to avoid errors\n\n\t\t\t\t\tconst tk = max( minThickness, this.thickness ).toVar();\n\n\t\t\t\t\tIf( away.lessThanEqual( tk ), () => { // hit\n\n\t\t\t\t\t\tconst vN = this.normalNode.sample( uvNode ).rgb.normalize().toVar();\n\n\t\t\t\t\t\tIf( dot( viewReflectDir, vN ).greaterThanEqual( 0 ), () => {\n\n\t\t\t\t\t\t\t// the reflected ray is pointing towards the same side as the fragment's normal (current ray position),\n\t\t\t\t\t\t\t// which means it wouldn't reflect off the surface. The loop continues to the next step for the next ray sample.\n\t\t\t\t\t\t\tContinue();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// this distance represents the depth of the intersection point between the reflected ray and the scene.\n\t\t\t\t\t\tconst distance = pointPlaneDistance( vP, viewPosition, viewNormal ).toVar();\n\n\t\t\t\t\t\tIf( distance.greaterThan( this.maxDistance ), () => {\n\n\t\t\t\t\t\t\t// Distance exceeding limit: The reflection is potentially too far away and\n\t\t\t\t\t\t\t// might not contribute significantly to the final color\n\t\t\t\t\t\t\tBreak();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst op = this.opacity.mul( metalness ).toVar();\n\n\t\t\t\t\t\t// distance attenuation (the reflection should fade out the farther it is away from the surface)\n\t\t\t\t\t\tconst ratio = float( 1 ).sub( distance.div( this.maxDistance ) ).toVar();\n\t\t\t\t\t\tconst attenuation = ratio.mul( ratio );\n\t\t\t\t\t\top.mulAssign( attenuation );\n\n\t\t\t\t\t\t// fresnel (reflect more light on surfaces that are viewed at grazing angles)\n\t\t\t\t\t\tconst fresnelCoe = div( dot( viewIncidentDir, viewReflectDir ).add( 1 ), 2 );\n\t\t\t\t\t\top.mulAssign( fresnelCoe );\n\n\t\t\t\t\t\t// output\n\t\t\t\t\t\tconst reflectColor = this.colorNode.sample( uvNode );\n\t\t\t\t\t\toutput.assign( vec4( reflectColor.rgb, op ) );\n\t\t\t\t\t\tBreak();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\treturn output;\n\n\t\t} );\n\n\t\tthis._ssrMaterial.fragmentNode = ssr().context( builder.getSharedContext() );\n\t\tthis._ssrMaterial.needsUpdate = true;\n\n\t\t// below materials are used for blurring\n\n\t\tconst reflectionBuffer = texture( this._ssrRenderTarget.texture );\n\n\t\tthis._blurMaterial.fragmentNode = boxBlur( reflectionBuffer, { size: this.blurQuality, separation: this._blurSpread } );\n\t\tthis._blurMaterial.needsUpdate = true;\n\n\t\tthis._copyMaterial.fragmentNode = reflectionBuffer;\n\t\tthis._copyMaterial.needsUpdate = true;\n\n\t\t//\n\n\t\treturn this.getTextureNode();\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._ssrRenderTarget.dispose();\n\t\tthis._blurRenderTarget.dispose();\n\n\t\tthis._ssrMaterial.dispose();\n\t\tthis._blurMaterial.dispose();\n\t\tthis._copyMaterial.dispose();\n\n\t}\n\n}\n\nexport default SSRNode;\n\n/**\n * TSL function for creating screen space reflections (SSR).\n *\n * @tsl\n * @function\n * @param {Node<vec4>} colorNode - The node that represents the beauty pass.\n * @param {Node<float>} depthNode - A node that represents the beauty pass's depth.\n * @param {Node<vec3>} normalNode - A node that represents the beauty pass's normals.\n * @param {Node<float>} metalnessNode - A node that represents the beauty pass's metalness.\n * @param {?Node<float>} [roughnessNode=null] - A node that represents the beauty pass's roughness.\n * @param {?Camera} [camera=null] - The camera the scene is rendered with.\n * @returns {SSRNode}\n */\nexport const ssr = ( colorNode, depthNode, normalNode, metalnessNode, roughnessNode = null, camera = null ) => nodeObject( new SSRNode( nodeObject( colorNode ), nodeObject( depthNode ), nodeObject( normalNode ), nodeObject( metalnessNode ), nodeObject( roughnessNode ), camera ) );\n"],
  "mappings": "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",
  "names": ["uv", "uv", "ssr", "uvNode"]
}
